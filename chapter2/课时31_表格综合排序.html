<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>表格综合应用-排序</title>
    <link type="text/css" rel="stylesheet" href="css/tab.css">
</head>
<body>
    <div class="box">
        <!--cellspacing = 单元格之间的距离，cellpadding = 单元格中内容和边沿的距离-->
        <table id="tab" cellspacing="0" cellpadding="0">
            <thead>
                <tr>
                    <th class="cursor" onclick="sort(this)">姓名</th>
                    <th class="cursor" onclick="sort(this)">年龄</th>
                    <th class="cursor" onclick="sort(this)">武力</th>
                    <th class="cursor" onclick="sort(this)">性别</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>任盈盈</td>
                    <td>22</td>
                    <td>80</td>
                    <td>女</td>
                </tr>
                <tr class="bg">
                    <td>岳林姗</td>
                    <td>21</td>
                    <td>88</td>
                    <td>女</td>
                </tr>
                <tr>
                    <td>岳不群</td>
                    <td>58</td>
                    <td>96</td>
                    <td>男</td>
                </tr>
                <tr class="bg">
                    <td>林平之</td>
                    <td>23</td>
                    <td>90</td>
                    <td>男</td>
                </tr>
                <tr>
                    <td>东方不败</td>
                    <td>30</td>
                    <td>100</td>
                    <td>男</td>
                </tr>
            </tbody>
        </table>
    </div>
    <script type="text/javascript">

        //算法分析：
        //1.那个table的那个tbody
        //2.看数据行是否小于2，小于就没必要排序
        //3.确定所点的列序号
        //4.tbody里的tr行对象转换成数组
        //5.在数组中用列序号确认用哪个值排序，取得时候直接拿到nodeValue
        //6.创建文档碎片
        //7.循环排序后的数组，逐一将tr_dom对象存入文档碎片的childList里
        //8.将文档碎片对象appendChild到tbody上
        function sort(th) {
            var tb = document.getElementsByTagName("tbody")[0]
            if(tb.children.length < 2) return // 如果就一行数据那就不排序了
            var columnIndex = -1 // 点的到底是哪一列
            var siblingThAry = [].__proto__.slice.call(th.parentNode.children)
            for (var i=0; i< siblingThAry.length; i++) {
                if(siblingThAry[i].isEqualNode((th))) {
                    columnIndex = i //第几列
                }
            }
            var rowsAry = [].__proto__.slice.call(tb.children)
            rowsAry.sort(function (a,b) {
                var curValue = a.children[columnIndex].firstChild.nodeValue
                var nextValue = b.children[columnIndex].firstChild.nodeValue
                if (isNaN(parseFloat(curValue)) || isNaN(parseFloat(nextValue))) {
                    return curValue.toString().localeCompare(nextValue.toString())
                }
                return parseFloat(curValue) - parseFloat(nextValue)
            })
            var frg = document.createDocumentFragment()
            rowsAry.forEach(function (item) { frg.appendChild(item)})
            tb.appendChild(frg)
        }
    </script>
</body>
</html>